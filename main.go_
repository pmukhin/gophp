package main

import (
	"os"
	"fmt"
	"bufio"
	"lang/scanner"
	"strconv"
	"errors"
)

type ASTType uint8

const (
	BinaryAST ASTType = iota
	ValueAST
)

var operatorPrecedence = map[scanner.TokenType]int{
	scanner.TokenPlus:  10,
	scanner.TokenMinus: 12,
	scanner.TokenDiv:   13,
	scanner.TokenMulti: 14,
}

var (
	out = os.Stdout
	in  = os.Stdin
)

type ValueType uint8

const (
	TypeInt   ValueType = iota
	TypeFloat
	TypeRune
)

type Value interface {
	Type() ValueType
}

type ValueArithmetic interface {
	Value
	Add(Value) (Value, error)
	Multiply(Value) (Value, error)
	Divide(Value) (Value, error)
	Subtract(Value) (Value, error)
}

type ValueInt struct {
	Data int64
}

func (v ValueInt) Add(o Value) (Value, error) {
	arg, e := v.inferArg(o, "add")
	if e != nil {
		return ValueInt{}, e
	}
	return ValueInt{Data: v.Data + arg}, nil
}

func (v ValueInt) Multiply(o Value) (Value, error) {
	arg, e := v.inferArg(o, "multiply")
	if e != nil {
		return ValueInt{}, e
	}
	return ValueInt{Data: v.Data + arg}, nil
}

func (v ValueInt) Divide(o Value) (Value, error) {
	arg, e := v.inferArg(o, "divide")
	if e != nil {
		return ValueInt{}, e
	}
	return ValueInt{Data: v.Data / arg}, nil
}

func (v ValueInt) Subtract(o Value) (Value, error) {
	arg, e := v.inferArg(o, "subtract")
	if e != nil {
		return ValueInt{}, e
	}
	return ValueInt{Data: v.Data + arg}, nil
}

func (v ValueInt) inferArg(o Value, action string) (int64, error) {
	switch o.Type() {
	case TypeInt:
		return o.(ValueInt).Data, nil
	case TypeFloat:
		return int64(o.(ValueFloat).Data), nil
	default:
		return 0, errors.New(fmt.Sprintf("can not %s object of type: %v", action, o.Type()))
	}
}

func (ValueInt) Type() ValueType {
	return TypeInt
}

type ValueFloat struct {
	Data float64
}

func (ValueFloat) Add(ValueArithmetic) (Value, error) {
	panic("implement me")
}

func (ValueFloat) Multiply(ValueArithmetic) (Value, error) {
	panic("implement me")
}

func (ValueFloat) Divide(ValueArithmetic) (Value, error) {
	panic("implement me")
}

func (ValueFloat) Subtract(ValueArithmetic) (Value, error) {
	panic("implement me")
}

func (ValueFloat) Type() ValueType {
	return TypeFloat
}

type (
	Operator interface {
		Operate(lhs, rhs Expr) Expr
	}

	Expr interface {
		Type() ASTType
		Val() (Value, error)
	}

	BinaryExpr struct {
		Op  byte
		LHS Expr
		RHS Expr
	}

	ValueExpr struct {
		Value Value
	}
)

func (ValueExpr) Type() ASTType {
	return ValueAST
}

func (v ValueExpr) Val() (Value, error) {
	return v.Value, nil
}

func (be BinaryExpr) Type() ASTType {
	return BinaryAST
}

func (be BinaryExpr) Val() (Value, error) {
	switch be.Op {
	case '+':
		return be.LHS.Val().(ValueArithmetic).Add(be.RHS.Val())
	case '-':
		return be.LHS.Val().(ValueArithmetic).Subtract(be.LHS.Val())
	case '*':
		return be.LHS.Val().(ValueArithmetic).Multiply(be.RHS.Val())
	case '/':
		return be.LHS.Val().(ValueArithmetic).Divide(be.RHS.Val())
	}
	return ValueInt{}, errors.New(fmt.Sprintf("undefined operator %s", string(be.Op)))
}

type Parser struct {
	scn scanner.Scanner
}

func (p *Parser) Parse() []Expr {
	exprs := make([]Expr, 0, 128)

	for p.scn.HasNext() {
		expr, err := p.parseExpr()
		if err != nil {
			panic(err)
		}
		exprs = append(exprs, expr)
	}

	return exprs
}

func (p *Parser) parseExpr() (Expr, error) {
	lhs, e := p.parseUnary()
	if e != nil {
		return lhs, e
	}
	return p.parseBinaryOperation(0, lhs)
}

func (p *Parser) parseUnary() (expr Expr, err error) {
	tok, _ := p.scn.Next()
	switch tok.Type {
	case scanner.TokenNumber:
		return p.parseNumber(tok)
	}
	return expr, errors.New("unexpected token " + tok.Literal)
}

func (p *Parser) parseBinaryOperation(prevPrec int, lhs Expr) (expr Expr, err error) {
	tok, err := p.scn.Next()
	if err != nil {
		return expr, err
	}
	prec, err := p.getPrecedence(tok)
	if err != nil {
		return expr, err
	}
	if prec < prevPrec {
		return lhs, err
	}
	rhs, err := p.parseUnary()
	if err != nil {
		return expr, err
	}
	expr = BinaryExpr{Op: []byte(tok.Literal)[0], LHS: lhs, RHS: rhs}

	return
}

func (p *Parser) parseNumber(tok scanner.Token) (ValueExpr, error) {
	v, err := strconv.ParseInt(tok.Literal, 10, 0)
	return ValueExpr{Value: ValueInt{Data: v}}, err
}

func (p *Parser) getPrecedence(token scanner.Token) (int, error) {
	if prec, ok := operatorPrecedence[token.Type]; ok {
		return prec, nil
	}
	return -1, nil
}

func main() {
	reader := bufio.NewReader(in)

	for {
		fmt.Fprintf(out, ">> ")
		line, _, err := reader.ReadLine()
		if err != nil {
			fmt.Fprintf(out, "error: %s", err.Error())
		}
		execute(string(line))
	}
}

func execute(line string) {
	scn := scanner.New([]rune(line))
	parser := Parser{scn: *scn}
	s := parser.Parse()

	for _, k := range s {
		fmt.Println(k.Val())
	}
}
